#!/usr/bin/env bash
#  TURBO RECORDER
# - If display capture >= 3840x2160: capture native 4K and encode with VAAPI (HEVC if available)
# - If display < 4K: capture native source and encode with very high-quality settings (libx265 CRF or hevc_vaapi fallback)
# - Reliable monitor + mic mixing, FLAC audio @ 96 kHz
# - Outputs to ~/Videos and ~/Audio by default
set -euo pipefail
IFS=$'\n\t'

# ---------------------------
# User-configurable defaults
# ---------------------------
VID_DIR="${VID_DIR:-$HOME/Videos}"
AUD_DIR="${AUD_DIR:-$HOME/Audio}"

TARGET_4K_W=3840
TARGET_4K_H=2160
OUTPUT_RES="${OUTPUT_RES:-3840x2160}"   # used only for upscaling when explicitly needed (default 4K)
FPS="${FPS:-23}"
VAAPI_DEVICE="${VAAPI_DEVICE:-/dev/dri/renderD128}"

# Encoder preferences
PREFER_HEVC_VAAPI="${PREFER_HEVC_VAAPI:-1}"  # 1 = prefer hevc_vaapi when available, 0 = prefer h264_vaapi
VAAPI_QP="${VAAPI_QP:-14}"                   # lower = higher quality for VAAPI
VAAPI_BITRATE="${VAAPI_BITRATE:-40000k}"     # used when VAAPI mode selected
VAAPI_MAXRATE="${VAAPI_MAXRATE:-60000k}"
VAAPI_BUFSIZE="${VAAPI_BUFSIZE:-60000k}"

# Software encoder fallback (very high visual quality)
SW_CRF="${SW_CRF:-18}"       # x265 CRF for visually high-quality archive (lower = better)
SW_PRESET="${SW_PRESET:-slow}"

AUDIO_RATE="${AUDIO_RATE:-96000}"

# Audio sources (set your exact monitor source if known)
# Example monitor sink from user: alsa_output.pci-0000_0b_00.6.analog-stereo
# Pulse monitor source usually ends with ".monitor"
MONITOR_SOURCE="${MONITOR_SOURCE:-alsa_output.pci-0000_0b_00.6.analog-stereo.monitor}"
PREFERRED_MIC="${PREFERRED_MIC:-}"   # leave empty to auto-detect

# ---------------------------
# Helpers
# ---------------------------
die(){ printf '%s\n' "$*" >&2; exit 1; }
ensure_dir(){ local d="$1"; [ -e "$d" ] && [ ! -d "$d" ] && die "Not a directory: $d"; mkdir -p "$d"; }
timestamp(){ date +"%Y-%m-%d_%H-%M-%S"; }

# Detect commands
require_cmd(){ command -v "$1" >/dev/null 2>&1 || die "Required command not found: $1"; }
require_cmd ffmpeg
require_cmd pactl
require_cmd awk

# ---------------------------
# Detect screen size
# ---------------------------
detect_screen_size(){
  local s=""
  if command -v xdpyinfo >/dev/null 2>&1; then
    s="$(xdpyinfo 2>/dev/null | awk '/dimensions:/ {print $2; exit}')"
  fi
  if [ -z "$s" ] && command -v xrandr >/dev/null 2>&1; then
    s="$(xrandr --query 2>/dev/null | awk '/ connected/ { split($3,a,/x/); if (a[1] ~ /^[0-9]+$/) { print a[1]"x"a[2]; exit } }')"
  fi
  printf '%s' "$s"
}

# ---------------------------
# Pulse source selection
# ---------------------------
find_pulse_source_by_pattern(){
  pactl list short sources 2>/dev/null | awk -v pat="$1" 'tolower($0) ~ tolower(pat) { print $1; exit }'
}

choose_mic_source(){
  if [ -n "$PREFERRED_MIC" ]; then
    MIC_SOURCE="$PREFERRED_MIC"
    return
  fi
  MIC_SOURCE="$(find_pulse_source_by_pattern "usb.*input" || true)"
  [ -z "$MIC_SOURCE" ] && MIC_SOURCE="$(find_pulse_source_by_pattern "alsa_input" || true)"
  [ -z "$MIC_SOURCE" ] && MIC_SOURCE="$(find_pulse_source_by_pattern "default" || true)"
  if [ -z "${MIC_SOURCE:-}" ]; then
    mapfile -t _srcs < <(pactl list short sources 2>/dev/null || true)
    if [ "${#_srcs[@]}" -gt 0 ]; then
      MIC_SOURCE="$(awk '{print $1}' <<<"${_srcs[0]}")"
    else
      MIC_SOURCE="default"
    fi
  fi
}

# ---------------------------
# Utility: check if encoder is available in ffmpeg
# ---------------------------
ffmpeg_has_encoder(){
  local enc="$1"
  ffmpeg -hide_banner -encoders 2>/dev/null | awk '{print $1}' | grep -xq "$enc"
}

# ---------------------------
# Audio mix filter builder
# ---------------------------
build_mix_filter(){
  # balance volumes here if needed
  local mon_vol=1.0
  local mic_vol=1.0
  printf "[0]aresample=48000,volume=%s[mon];[1]aformat=sample_rates=48000:channel_layouts=mono|stereo,pan=stereo|c0=c0|c1=c0,volume=%s[mic];[mon][mic]amix=inputs=2:weights=%s %s:duration=longest:dropout_transition=2,aresample=%s[a]" \
    "$mon_vol" "$mic_vol" "$mon_vol" "$mic_vol" "$AUDIO_RATE"
}

# ---------------------------
# Build the ffmpeg command based on detection
# ---------------------------
run_record_native_4k_vaapi(){
  ensure_dir "$VID_DIR"
  ensure_dir "$AUD_DIR"
  choose_mic_source

  # prefer hevc_vaapi if available and allowed, else h264_vaapi, else fall back to software libx265
  local enc
  if [ "$PREFER_HEVC_VAAPI" -eq 1 ] && ffmpeg_has_encoder hevc_vaapi; then
    enc="hevc_vaapi"
  elif ffmpeg_has_encoder h264_vaapi; then
    enc="h264_vaapi"
  else
    enc=""
  fi

  if [ -n "$enc" ]; then
    printf 'Recording native 4K -> hardware encoder: %s\nMonitor: %s  Mic: %s\n' "$enc" "$MONITOR_SOURCE" "$MIC_SOURCE" >&2
    ffmpeg -hide_banner -y \
      -vaapi_device "$VAAPI_DEVICE" \
      -f x11grab -r "$FPS" -s "${TARGET_4K_W}x${TARGET_4K_H}" -i ":0.0+0,0" \
      -f pulse -thread_queue_size 1024 -i "$MONITOR_SOURCE" \
      -f pulse -thread_queue_size 1024 -i "$MIC_SOURCE" \
      -filter_complex "$(build_mix_filter)" \
      -map 0:v -map "[a]" \
      -vf format=nv12,hwupload \
      -c:v "$enc" -qp "$VAAPI_QP" -b:v "$VAAPI_BITRATE" -maxrate "$VAAPI_MAXRATE" -bufsize "$VAAPI_BUFSIZE" -profile:v main \
      -c:a flac -ar "$AUDIO_RATE" -ac 2 \
      "${VID_DIR}/capture_4k_$(timestamp).mkv"
  else
    # fallback to software x265 with high quality CRF
    printf 'Recording native 4K -> software x265 (fallback)\nMonitor: %s  Mic: %s\n' "$MONITOR_SOURCE" "$MIC_SOURCE" >&2
    ffmpeg -hide_banner -y \
      -f x11grab -r "$FPS" -s "${TARGET_4K_W}x${TARGET_4K_H}" -i ":0.0+0,0" \
      -f pulse -thread_queue_size 1024 -i "$MONITOR_SOURCE" \
      -f pulse -thread_queue_size 1024 -i "$MIC_SOURCE" \
      -filter_complex "$(build_mix_filter)" \
      -map 0:v -map "[a]" \
      -c:v libx265 -preset "$SW_PRESET" -crf "$SW_CRF" \
      -c:a flac -ar "$AUDIO_RATE" -ac 2 \
      "${VID_DIR}/capture_4k_x265_$(timestamp).mkv"
  fi
}

run_record_native_source_best(){
  ensure_dir "$VID_DIR"
  ensure_dir "$AUD_DIR"
  choose_mic_source

  local W="$1" H="$2"
  # choose best encoder: prefer hevc_vaapi/h264_vaapi (will hwupload), else libx265
  local enc=""
  if [ "$PREFER_HEVC_VAAPI" -eq 1 ] && ffmpeg_has_encoder hevc_vaapi; then
    enc="hevc_vaapi"
  elif ffmpeg_has_encoder h264_vaapi; then
    enc="h264_vaapi"
  fi

  if [ -n "$enc" ]; then
    printf 'Recording native %sx%s -> hardware encoder: %s\nMonitor: %s  Mic: %s\n' "$W" "$H" "$enc" "$MONITOR_SOURCE" "$MIC_SOURCE" >&2
    ffmpeg -hide_banner -y \
      -vaapi_device "$VAAPI_DEVICE" \
      -f x11grab -r "$FPS" -s "${W}x${H}" -i ":0.0+0,0" \
      -f pulse -thread_queue_size 1024 -i "$MONITOR_SOURCE" \
      -f pulse -thread_queue_size 1024 -i "$MIC_SOURCE" \
      -filter_complex "$(build_mix_filter)" \
      -map 0:v -map "[a]" \
      -vf format=nv12,hwupload \
      -c:v "$enc" -qp "$VAAPI_QP" -b:v "$VAAPI_BITRATE" -maxrate "$VAAPI_MAXRATE" -bufsize "$VAAPI_BUFSIZE" -profile:v main \
      -c:a flac -ar "$AUDIO_RATE" -ac 2 \
      "${VID_DIR}/capture_${W}x${H}_$(timestamp).mkv"
  else
    printf 'Recording native %sx%s -> software x265 (high-quality)\nMonitor: %s  Mic: %s\n' "$W" "$H" "$MONITOR_SOURCE" "$MIC_SOURCE" >&2
    ffmpeg -hide_banner -y \
      -f x11grab -r "$FPS" -s "${W}x${H}" -i ":0.0+0,0" \
      -f pulse -thread_queue_size 1024 -i "$MONITOR_SOURCE" \
      -f pulse -thread_queue_size 1024 -i "$MIC_SOURCE" \
      -filter_complex "$(build_mix_filter)" \
      -map 0:v -map "[a]" \
      -c:v libx265 -preset "$SW_PRESET" -crf "$SW_CRF" \
      -c:a flac -ar "$AUDIO_RATE" -ac 2 \
      "${VID_DIR}/capture_${W}x${H}_x265_$(timestamp).mkv"
  fi
}

# ---------------------------
# CLI / Menu
# ---------------------------
print_help(){
  cat <<EOF
Usage: $0 [options]
Options:
  -m MODE    mode (audio_internal,audio_mic,audio_both,video_auto)
  -o DIR     output directory for both video/audio
  -f FPS     frames per second
  -q QP      VAAPI QP (lower = better)
  -b BITRATE VAAPI bitrate (e.g., 40000k)
  -h         show help
EOF
}

MODE=""
while getopts ":m:o:f:q:b:h" opt; do
  case "$opt" in
    m) MODE="$OPTARG" ;;
    o) VID_DIR="$OPTARG"; AUD_DIR="$OPTARG" ;;
    f) FPS="$OPTARG" ;;
    q) VAAPI_QP="$OPTARG" ;;
    b) VAAPI_BITRATE="$OPTARG" ;;
    h) print_help; exit 0 ;;
    \?) die "Invalid option: -$OPTARG" ;;
    :) die "Option -$OPTARG requires an argument." ;;
  esac
done

# ---------------------------
# Main logic: detect and choose pipeline
# ---------------------------
SCREEN="$(detect_screen_size || true)"
if [ -z "$SCREEN" ]; then
  printf 'Warning: could not detect screen size. Defaulting to native capture with best encoder.\n' >&2
  SW_W=1920; SW_H=1080
else
  SW_W="${SCREEN%x*}"; SW_H="${SCREEN#*x}"
fi

# Ensure mic selected
choose_mic_source

printf 'Detected screen: %s  (width=%s height=%s)\n' "${SCREEN:-unknown}" "$SW_W" "$SW_H" >&2
printf 'Monitor source: %s\nMic source: %s\n' "$MONITOR_SOURCE" "$MIC_SOURCE" >&2

# Modes
if [ -z "${MODE:-}" ]; then
  echo "Choose an option:"
  echo "1) audio internal"
  echo "2) microphone only"
  echo "3) audio internal + microphone (audio file)"
  echo "4) video (auto: choose best pipeline for source; prefer native 4K if available)"
  echo "5) quit"
  printf "Enter choice [1-5]: "
  read -r CHOICE
else
  case "$MODE" in
    audio_internal) CHOICE=1 ;;
    audio_mic)      CHOICE=2 ;;
    audio_both)     CHOICE=3 ;;
    video_auto)     CHOICE=4 ;;
    *) CHOICE=5 ;;
  esac
fi

case "$CHOICE" in
  1)
    ensure_dir "$AUD_DIR"
    ffmpeg -hide_banner -y -f pulse -thread_queue_size 1024 -i "$MONITOR_SOURCE" -af "aresample=${AUDIO_RATE}" -c:a flac -ar "$AUDIO_RATE" -ac 2 "${AUD_DIR}/audio_internal_$(timestamp).flac"
    ;;
  2)
    ensure_dir "$AUD_DIR"
    ffmpeg -hide_banner -y -f pulse -thread_queue_size 1024 -i "$MIC_SOURCE" -af "aformat=channel_layouts=mono|stereo,pan=stereo|c0=c0|c1=c0,aresample=${AUDIO_RATE}" -c:a flac -ar "$AUDIO_RATE" -ac 2 "${AUD_DIR}/audio_mic_$(timestamp).flac"
    ;;
  3)
    ensure_dir "$AUD_DIR"
    ffmpeg -hide_banner -y -f pulse -thread_queue_size 1024 -i "$MONITOR_SOURCE" -f pulse -thread_queue_size 1024 -i "$MIC_SOURCE" -filter_complex "$(build_mix_filter)" -map "[a]" -c:a flac -ar "$AUDIO_RATE" -ac 2 "${AUD_DIR}/audio_mixed_$(timestamp).flac"
    ;;
  4)
    # If display is >= 4K, capture native 4K
    if [ -n "$SW_W" ] && [ -n "$SW_H" ] && [ "$SW_W" -ge "$TARGET_4K_W" ] && [ "$SW_H" -ge "$TARGET_4K_H" ]; then
      run_record_native_4k_vaapi
    else
      # Else capture native source resolution with best settings
      run_record_native_source_best "$SW_W" "$SW_H"
    fi
    ;;
  5)
    printf 'Exiting\n'; exit 0
    ;;
  *)
    die "Invalid selection: $CHOICE"
    ;;
esac
