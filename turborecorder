#!/usr/bin/env bash
# TURBO RECORDER
# - Options: 1) audio internal 2) microphone only 3) audio internal + microphone
#            4) video no audio 5) video internal 6) video microphone 7) video both 8) quit
# - Auto-detects screen resolution and picks best pipeline for true 4K (no upscaling) when available
# - Prefers VAAPI HEVC/H264 encoders, falls back to libx265 for highest quality when needed
# - Reliable PulseAudio monitor + mic mixing, FLAC audio @ 96 kHz
set -euo pipefail
IFS=$'\n\t'

# ---------------------------------------------------------------------------
# Configurable defaults
# ---------------------------------------------------------------------------
VID_DIR="${VID_DIR:-$HOME/Videos}"
AUD_DIR="${AUD_DIR:-$HOME/Audio}"

TARGET_4K_W=3840
TARGET_4K_H=2160

FPS="${FPS:-23}"
VAAPI_DEVICE="${VAAPI_DEVICE:-/dev/dri/renderD128}"

# Encoder preferences
PREFER_HEVC_VAAPI="${PREFER_HEVC_VAAPI:-1}"  # 1 = prefer hevc_vaapi when available
VAAPI_QP="${VAAPI_QP:-14}"                   # lower => better visual quality
VAAPI_BITRATE="${VAAPI_BITRATE:-40000k}"
VAAPI_MAXRATE="${VAAPI_MAXRATE:-60000k}"
VAAPI_BUFSIZE="${VAAPI_BUFSIZE:-60000k}"

# Software encoder fallback (very high visual quality)
SW_CRF="${SW_CRF:-18}"       # x265 CRF (lower => better)
SW_PRESET="${SW_PRESET:-slow}"

AUDIO_RATE="${AUDIO_RATE:-96000}"

# Monitor source (set to your Pulse monitor source). User provided sink:
# alsa_output.pci-0000_0b_00.6.analog-stereo
MONITOR_SOURCE="${MONITOR_SOURCE:-alsa_output.pci-0000_0b_00.6.analog-stereo.monitor}"
PREFERRED_MIC="${PREFERRED_MIC:-}"   # leave empty to auto-detect

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
die(){ printf '%s\n' "$*" >&2; exit 1; }
ensure_dir(){ local d="$1"; [ -e "$d" ] && [ ! -d "$d" ] && die "Not a directory: $d"; mkdir -p "$d"; }
timestamp(){ date +"%Y-%m-%d_%H-%M-%S"; }

require_cmd(){ command -v "$1" >/dev/null 2>&1 || die "Required command not found: $1"; }
require_cmd ffmpeg
require_cmd pactl
require_cmd awk

# ---------------------------------------------------------------------------
# Screen detection
# ---------------------------------------------------------------------------
detect_screen_size(){
  local s=""
  if command -v xdpyinfo >/dev/null 2>&1; then
    s="$(xdpyinfo 2>/dev/null | awk '/dimensions:/ {print $2; exit}')"
  fi
  if [ -z "$s" ] && command -v xrandr >/dev/null 2>&1; then
    s="$(xrandr --query 2>/dev/null | awk '/ connected/ { split($3,a,/x/); if (a[1] ~ /^[0-9]+$/) { print a[1]"x"a[2]; exit } }')"
  fi
  printf '%s' "$s"
}

# ---------------------------------------------------------------------------
# Pulse helpers
# ---------------------------------------------------------------------------
find_pulse_source_by_pattern(){
  pactl list short sources 2>/dev/null | awk -v pat="$1" 'tolower($0) ~ tolower(pat) { print $1; exit }'
}

choose_mic_source(){
  if [ -n "$PREFERRED_MIC" ]; then
    MIC_SOURCE="$PREFERRED_MIC"
    return
  fi
  MIC_SOURCE="$(find_pulse_source_by_pattern "usb.*input" || true)"
  [ -z "$MIC_SOURCE" ] && MIC_SOURCE="$(find_pulse_source_by_pattern "alsa_input" || true)"
  [ -z "$MIC_SOURCE" ] && MIC_SOURCE="$(find_pulse_source_by_pattern "default" || true)"
  if [ -z "${MIC_SOURCE:-}" ]; then
    mapfile -t _srcs < <(pactl list short sources 2>/dev/null || true)
    if [ "${#_srcs[@]}" -gt 0 ]; then
      MIC_SOURCE="$(awk '{print $1}' <<<"${_srcs[0]}")"
    else
      MIC_SOURCE="default"
    fi
  fi
}

# ---------------------------------------------------------------------------
# FFmpeg encoder availability check
# ---------------------------------------------------------------------------
ffmpeg_has_encoder(){
  local enc="$1"
  ffmpeg -hide_banner -encoders 2>/dev/null | awk '{print $1}' | grep -xq "$enc"
}

# ---------------------------------------------------------------------------
# Audio mix filter builder (inputs: 0=monitor,1=mic). Outputs label [a]
# ---------------------------------------------------------------------------
build_mix_filter(){
  local mon_vol=1.0
  local mic_vol=1.0
  printf "[0]aresample=48000,volume=%s[mon];[1]aformat=sample_rates=48000:channel_layouts=mono|stereo,pan=stereo|c0=c0|c1=c0,volume=%s[mic];[mon][mic]amix=inputs=2:weights=%s %s:duration=longest:dropout_transition=2,aresample=%s[a]" \
    "$mon_vol" "$mic_vol" "$mon_vol" "$mic_vol" "$AUDIO_RATE"
}

# ---------------------------------------------------------------------------
# Pipelines
# ---------------------------------------------------------------------------
run_audio_internal_only(){
  ensure_dir "$AUD_DIR"
  ffmpeg -hide_banner -y -f pulse -thread_queue_size 1024 -i "$MONITOR_SOURCE" -af "aresample=${AUDIO_RATE}" -c:a flac -ar "$AUDIO_RATE" -ac 2 "${AUD_DIR}/audio_internal_$(timestamp).flac"
}

run_audio_mic_only(){
  ensure_dir "$AUD_DIR"
  choose_mic_source
  ffmpeg -hide_banner -y -f pulse -thread_queue_size 1024 -i "$MIC_SOURCE" -af "aformat=channel_layouts=mono|stereo,pan=stereo|c0=c0|c1=c0,aresample=${AUDIO_RATE}" -c:a flac -ar "$AUDIO_RATE" -ac 2 "${AUD_DIR}/audio_mic_$(timestamp).flac"
}

run_audio_internal_and_mic(){
  ensure_dir "$AUD_DIR"
  choose_mic_source
  ffmpeg -hide_banner -y -f pulse -thread_queue_size 1024 -i "$MONITOR_SOURCE" -f pulse -thread_queue_size 1024 -i "$MIC_SOURCE" -filter_complex "$(build_mix_filter)" -map "[a]" -c:a flac -ar "$AUDIO_RATE" -ac 2 "${AUD_DIR}/audio_mixed_$(timestamp).flac"
}

# Video - no audio (screen only)
run_video_noaudio(){
  ensure_dir "$VID_DIR"
  choose_mic_source
  detect_and_record_video "" "" noaudio
}

# Video - internal monitor audio only
run_video_internal(){
  ensure_dir "$VID_DIR"
  choose_mic_source
  detect_and_record_video "$MONITOR_SOURCE" "" video_internal
}

# Video - microphone only
run_video_mic(){
  ensure_dir "$VID_DIR"
  choose_mic_source
  detect_and_record_video "" "$MIC_SOURCE" video_mic
}

# Video - both monitor + mic
run_video_both(){
  ensure_dir "$VID_DIR"
  choose_mic_source
  detect_and_record_video "$MONITOR_SOURCE" "$MIC_SOURCE" video_both
}

# Core function: choose pipeline based on detected screen size
detect_and_record_video(){
  local src_monitor="$1"
  local src_mic="$2"
  local mode="$3"

  # Detect screen
  local SCREEN
  SCREEN="$(detect_screen_size || true)"
  local SW_W SW_H
  if [ -z "$SCREEN" ]; then
    # fallback: assume 1920x1080
    SW_W=1920; SW_H=1080
  else
    SW_W="${SCREEN%x*}"; SW_H="${SCREEN#*x}"
  fi

  # Choose encoder
  local enc=""
  if [ "$PREFER_HEVC_VAAPI" -eq 1 ] && ffmpeg_has_encoder hevc_vaapi; then
    enc="hevc_vaapi"
  elif ffmpeg_has_encoder h264_vaapi; then
    enc="h264_vaapi"
  fi

  # Build audio mapping arguments
  local audio_inputs=()
  local filter_complex=""
  local map_audio=""
  if [ "$mode" = "noaudio" ]; then
    :
  elif [ -n "$src_monitor" ] && [ -n "$src_mic" ]; then
    # monitor + mic
    audio_inputs=( -f pulse -thread_queue_size 1024 -i "$src_monitor" -f pulse -thread_queue_size 1024 -i "$src_mic" )
    filter_complex="$(build_mix_filter)"
    map_audio="-map [a]"
  elif [ -n "$src_monitor" ]; then
    audio_inputs=( -f pulse -thread_queue_size 1024 -i "$src_monitor" )
    # single audio input will be remapped below
  elif [ -n "$src_mic" ]; then
    audio_inputs=( -f pulse -thread_queue_size 1024 -i "$src_mic" )
  fi

  # If display >= 4K, capture native 4K (no scaling)
  if [ "$SW_W" -ge "$TARGET_4K_W" ] && [ "$SW_H" -ge "$TARGET_4K_H" ]; then
    local cap_w=$TARGET_4K_W
    local cap_h=$TARGET_4K_H
  else
    local cap_w="$SW_W"
    local cap_h="$SW_H"
  fi

  # Compose ffmpeg command
  if [ -n "$enc" ]; then
    # VAAPI path
    if [ "$mode" = "noaudio" ]; then
      ffmpeg -hide_banner -y \
        -vaapi_device "$VAAPI_DEVICE" \
        -f x11grab -r "$FPS" -s "${cap_w}x${cap_h}" -i ":0.0+0,0" \
        -vf format=nv12,hwupload \
        -c:v "$enc" -qp "$VAAPI_QP" -b:v "$VAAPI_BITRATE" -maxrate "$VAAPI_MAXRATE" -bufsize "$VAAPI_BUFSIZE" \
        "${VID_DIR}/video_noaudio_$(timestamp).mkv"
    else
      # with audio (single or mixed)
      # When only one audio input is present (monitor OR mic) the mapping differs:
      if [ "${#audio_inputs[@]}" -eq 2 ]; then
        # single audio input
        ffmpeg -hide_banner -y \
          -vaapi_device "$VAAPI_DEVICE" \
          -f x11grab -r "$FPS" -s "${cap_w}x${cap_h}" -i ":0.0+0,0" \
          "${audio_inputs[@]}" \
          -map 0:v -map 1:a \
          -vf format=nv12,hwupload \
          -c:v "$enc" -qp "$VAAPI_QP" -b:v "$VAAPI_BITRATE" -maxrate "$VAAPI_MAXRATE" -bufsize "$VAAPI_BUFSIZE" \
          -c:a flac -ar "$AUDIO_RATE" -ac 2 \
          "${VID_DIR}/video_$(timestamp).mkv"
      else
        # two audio inputs -> mix
        ffmpeg -hide_banner -y \
          -vaapi_device "$VAAPI_DEVICE" \
          -f x11grab -r "$FPS" -s "${cap_w}x${cap_h}" -i ":0.0+0,0" \
          "${audio_inputs[@]}" \
          -filter_complex "$filter_complex" \
          -map 0:v -map "[a]" \
          -vf format=nv12,hwupload \
          -c:v "$enc" -qp "$VAAPI_QP" -b:v "$VAAPI_BITRATE" -maxrate "$VAAPI_MAXRATE" -bufsize "$VAAPI_BUFSIZE" \
          -c:a flac -ar "$AUDIO_RATE" -ac 2 \
          "${VID_DIR}/video_$(timestamp).mkv"
      fi
    fi
  else
    # Software encoder fallback (libx265) for highest-quality archive
    if [ "$mode" = "noaudio" ]; then
      ffmpeg -hide_banner -y \
        -f x11grab -r "$FPS" -s "${cap_w}x${cap_h}" -i ":0.0+0,0" \
        -c:v libx265 -preset "$SW_PRESET" -crf "$SW_CRF" \
        "${VID_DIR}/video_x265_$(timestamp).mkv"
    else
      if [ "${#audio_inputs[@]}" -eq 2 ]; then
        ffmpeg -hide_banner -y \
          -f x11grab -r "$FPS" -s "${cap_w}x${cap_h}" -i ":0.0+0,0" \
          "${audio_inputs[@]}" \
          -map 0:v -map 1:a \
          -c:v libx265 -preset "$SW_PRESET" -crf "$SW_CRF" \
          -c:a flac -ar "$AUDIO_RATE" -ac 2 \
          "${VID_DIR}/video_x265_$(timestamp).mkv"
      else
        ffmpeg -hide_banner -y \
          -f x11grab -r "$FPS" -s "${cap_w}x${cap_h}" -i ":0.0+0,0" \
          "${audio_inputs[@]}" \
          -filter_complex "$filter_complex" \
          -map 0:v -map "[a]" \
          -c:v libx265 -preset "$SW_PRESET" -crf "$SW_CRF" \
          -c:a flac -ar "$AUDIO_RATE" -ac 2 \
          "${VID_DIR}/video_x265_$(timestamp).mkv"
      fi
    fi
  fi
}

# ---------------------------------------------------------------------------
# CLI / Menu
# ---------------------------------------------------------------------------
print_help(){
  cat <<EOF
Usage: $0 [options]
Options:
  -m MODE    mode (audio_internal,audio_mic,audio_both,video_noaudio,video_internal,video_mic,video_both)
  -o DIR     output directory for both video/audio
  -f FPS     frames per second
  -q QP      VAAPI QP (lower = better)
  -b BITRATE VAAPI bitrate (e.g., 40000k)
  -h         show help
EOF
}

MODE=""
while getopts ":m:o:f:q:b:h" opt; do
  case "$opt" in
    m) MODE="$OPTARG" ;;
    o) VID_DIR="$OPTARG"; AUD_DIR="$OPTARG" ;;
    f) FPS="$OPTARG" ;;
    q) VAAPI_QP="$OPTARG" ;;
    b) VAAPI_BITRATE="$OPTARG" ;;
    h) print_help; exit 0 ;;
    \?) die "Invalid option: -$OPTARG" ;;
    :) die "Option -$OPTARG requires an argument." ;;
  esac
done

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------
choose_mic_source
SCREEN="$(detect_screen_size || true)"
SW_W="${SCREEN%x*}"; SW_H="${SCREEN#*x}"
if [ -z "$SW_W" ] || [ -z "$SW_H" ]; then SW_W=1920; SW_H=1080; fi

printf 'Using monitor source: %s\nUsing mic source: %s\nDetected screen: %sx%s\n' "$MONITOR_SOURCE" "${MIC_SOURCE:-unknown}" "$SW_W" "$SW_H" >&2

if [ -z "${MODE:-}" ]; then
  echo "Choose an option:"
  echo "1) audio internal"
  echo "2) microphone only"
  echo "3) audio internal + microphone"
  echo "4) video no audio"
  echo "5) video internal (monitor audio)"
  echo "6) video microphone (mic only)"
  echo "7) video both (monitor + mic)"
  echo "8) quit"
  printf "Enter choice [1-8]: "
  read -r CHOICE
else
  case "$MODE" in
    audio_internal) CHOICE=1 ;;
    audio_mic)      CHOICE=2 ;;
    audio_both)     CHOICE=3 ;;
    video_noaudio)  CHOICE=4 ;;
    video_internal) CHOICE=5 ;;
    video_mic)      CHOICE=6 ;;
    video_both)     CHOICE=7 ;;
    *) CHOICE=8 ;;
  esac
fi

case "$CHOICE" in
  1) run_audio_internal_only ;;
  2) run_audio_mic_only ;;
  3) run_audio_internal_and_mic ;;
  4) run_video_noaudio ;;
  5) run_video_internal ;;
  6) run_video_mic ;;
  7) run_video_both ;;
  8) printf 'Exiting\n'; exit 0 ;;
  *) die "Invalid selection: $CHOICE" ;;
esac
